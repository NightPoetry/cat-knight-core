# 数据库语法与事务语法解析机制总结

## 一、解析器架构与设计思路

### 1. 整体架构
- **SqlFunctionParser** 是核心解析器类，负责解析数据库定义和事务函数
- **多阶段解析策略**：
  - 第一阶段：解析所有表定义
  - 第二阶段：验证架构完整性
  - 第三阶段：生成触发器（孤儿删除）
  - 第四阶段：解析事务函数
- **适配器模式**：支持不同数据库后端（SQLite、JSON等），通过统一接口生成对应SQL或操作

### 2. 设计思路
- **DSL优先**：采用自然语言风格的领域特定语言，降低使用门槛
- **分层解析**：词法分析→语法分析→语义分析→代码生成
- **AST驱动**：使用抽象语法树表示解析结果，便于后续处理和代码生成
- **解释执行**：事务函数采用解释执行方式，支持动态上下文和变量

## 二、数据库语法解析

### 1. 表定义解析

**语法示例**：
```
User{
    string:id [primary]
    string[50]:email [not null] [unique]
    number(10,2):balance
    bool:active
    List[Role]:roles
}
```

**解析流程**：
1. **实体识别**：匹配以 `EntityName{` 开头的行，识别实体名称和所有者
2. **字段解析**：
   - 使用正则 `/^(\w+(?:\[[^\]]+\])?|List\[[^\]]+\]):(\w+)/i` 匹配字段类型和名称
   - 解析默认值（格式：`(默认值)`）
   - 识别约束属性：`[primary]`、`[not null]`、`[unique]`
3. **关系处理**：
   - 识别 `List[Target]` 格式的关系字段
   - 延迟处理关系，直到所有实体都解析完成
4. **表创建**：调用适配器的 `ensureTable` 方法生成对应SQL

**生成的SQL结构**：
```sql
CREATE TABLE IF NOT EXISTS "User" (
    "id" TEXT PRIMARY KEY,
    "email" TEXT NOT NULL UNIQUE,
    "balance" TEXT,
    "active" INTEGER
);
```

### 2. 关系表解析

**语法**：通过 `List[Target]` 字段隐式定义

**解析流程**：
1. 收集所有关系定义
2. 为每个关系创建关联表：
   - 表名采用字母序（如 `Product_User` 而非 `User_Product`）
   - 主键为两个实体主键的组合
   - 生成外键约束
3. 注册关系信息，用于后续触发器生成

**生成的SQL**：
```sql
CREATE TABLE IF NOT EXISTS "product_user" (
    "product_id" TEXT NOT NULL,
    "user_id" TEXT NOT NULL,
    "create_time" TEXT DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY ("product_id", "user_id"),
    FOREIGN KEY ("product_id") REFERENCES "Product"("id") ON DELETE CASCADE,
    FOREIGN KEY ("user_id") REFERENCES "User"("id") ON DELETE CASCADE
);
```

### 3. 触发器解析

**触发条件**：当实体有多个所有者时，自动生成孤儿清理触发器

**解析流程**：
1. 识别有所有者的实体
2. 收集所有相关关系表
3. 为每个关系表生成触发器：
   - 当从关系表删除记录时触发
   - 检查实体是否仍被其他关系引用
   - 如果没有引用，删除该实体

**生成的SQL**：
```sql
CREATE TRIGGER IF NOT EXISTS auto_gc_user_from_product_user
AFTER DELETE ON "product_user"
BEGIN
    DELETE FROM "User"
    WHERE "id" = OLD."user_id"
    AND NOT EXISTS (SELECT 1 FROM "other_rel" WHERE "user_id" = OLD."user_id");
END;
```

## 三、事务语法解析

### 1. 函数定义解析

**语法示例**：
```
TransferFunds(sourceId:string, targetId:string, amount:number(10,2)):
    Get a User by id of {sourceId} as sourceUser
    Get a User by id of {targetId} as targetUser
    Set {newSourceBalance} = {sourceUser.balance} - {amount}
    Set {newTargetBalance} = {targetUser.balance} + {amount}
    Update sourceUser to set balance = {newSourceBalance}
    Update targetUser to set balance = {newTargetBalance}
```

**解析流程**：
1. **函数识别**：匹配 `FunctionName(params):` 格式的行
2. **参数解析**：解析参数名称、类型和默认值
3. **主体解析**：
   - 使用缩进栈处理代码块
   - 逐行解析语句，生成AST节点
4. **API生成**：创建可执行函数，包装事务逻辑

### 2. 语句解析

| 语句类型 | 语法示例 | 解析结果 | 生成的SQL/操作 |
|---------|---------|---------|---------------|
| **Get** | `Get a User by id of {id} as targetUser` | `{ type: 'Get', entity: 'User', condition: 'id of {id}', alias: 'targetUser' }` | `SELECT * FROM "User" WHERE "id" = ? LIMIT 1` |
| **Create** | `Create a User with id of {id} and name of {name} as newUser` | `{ type: 'Create', raw: 'Create a User...' }` | `INSERT INTO "User" ("id", "name") VALUES (?, ?)` |
| **Update** | `Update sourceUser to set balance = {newBalance}` | `{ type: 'Update', raw: 'Update sourceUser...' }` | `UPDATE "User" SET "balance" = ? WHERE "id" = ?` |
| **Set** | `Set {newBalance} = {balance} - {amount}` | `{ type: 'Set', var: 'newBalance', value: '{balance} - {amount}' }` | 变量赋值，不生成SQL |
| **If** | `If {balance} > {amount}:` | `{ type: 'If', condition: '{balance} > {amount}' }` | 条件判断，不生成SQL |
| **ForEach** | `For Each item in {items}:` | `{ type: 'ForEach', item: 'item', list: '{items}' }` | 循环遍历，不生成SQL |
| **Return** | `return {result}` | `{ type: 'Return', value: '{result}' }` | 返回结果，不生成SQL |

### 3. 表达式解析

**语法示例**：`{balance} - {amount}`、`"string" + "suffix"`

**解析流程**：
1. **词法分析**：将表达式拆分为标记（变量、数字、字符串、运算符）
2. **Shunting Yard算法**：将中缀表达式转换为逆波兰表示法（RPN）
3. **RPN评估**：
   - 解析变量引用（格式：`{var}`）
   - 执行数学运算（+、-、*、/）
   - 处理字符串拼接

**生成的操作**：
- 变量引用：从上下文获取对应值
- 数学运算：调用DBNumber的方法（add、sub、mul、div）
- 比较运算：调用DBType的比较方法（eq、gt、lt等）

### 4. 条件解析

**语法示例**：`{balance} is greater than {amount}`、`{status} == "active"`

**解析流程**：
1. **运算符标准化**：将自然语言运算符转换为符号运算符
   - `is equal to` → `==`
   - `is greater than` → `>`
   - `is less than` → `<`
2. **表达式评估**：调用表达式解析器评估条件
3. **结果返回**：返回布尔值，用于控制流程

## 四、解析执行流程

### 1. 事务执行

```
1. 开始事务：调用适配器的 `beginTransaction`
2. 初始化上下文：包含变量、实体定义和适配器
3. 参数初始化：将传入参数转换为DBType对象
4. 执行语句块：
   - 遍历AST节点
   - 调用对应语句处理器（handleGet、handleCreate等）
   - 维护上下文变量
5. 提交或回滚：
   - 成功：调用适配器的 `commit`
   - 失败：调用适配器的 `rollback`
```

### 2. 语句执行示例

**Get语句执行**：
```javascript
async handleGet(stmt, context) {
    // 1. 解析实体类型
    // 2. 提取条件参数
    // 3. 调用适配器查询
    // 4. 包装结果为Entity对象
    // 5. 保存到上下文变量
}
```

**Create语句执行**：
```javascript
async handleCreate(stmt, context) {
    // 1. 解析实体类型
    // 2. 提取字段值
    // 3. 调用适配器插入
    // 4. 包装结果为Entity对象
    // 5. 保存到上下文变量
}
```

## 五、关键技术点

### 1. 动态类型系统
- 支持自定义数据类型（DBNumber、DBString、DBBool、DBDateTime）
- 自动类型转换和验证
- 精确的小数计算支持

### 2. 约束处理
- [primary]：标记主键
- [not null]：非空约束
- [unique]：唯一约束
- 支持多字段组合约束

### 3. 事务管理
- 支持完整的ACID特性
- 自动提交和回滚
- 嵌套事务支持

### 4. 延迟加载
- 关系字段采用延迟加载机制
- 提高初始加载性能
- 按需加载关联数据

## 六、解析器的扩展性

1. **支持新语句类型**：在 `parseStatement` 方法中添加新的语句匹配规则
2. **支持新数据类型**：扩展 `wrapValue` 方法
3. **支持新数据库后端**：实现适配器接口
4. **支持新约束类型**：在字段解析中添加新的约束处理

## 七、总结

SqlFunctionParser采用了**分层解析+解释执行**的设计思路，将自然语言风格的DSL转换为可执行的数据库操作。其核心优势在于：

1. **易用性**：自然语言风格降低了学习曲线
2. **灵活性**：支持多种数据库后端
3. **安全性**：参数化查询，防止SQL注入
4. **可靠性**：完整的事务支持和约束验证
5. **扩展性**：模块化设计，便于扩展新功能

这种解析机制使得开发者可以使用简洁的语法定义数据库结构和事务逻辑，同时获得底层数据库的强大功能支持。